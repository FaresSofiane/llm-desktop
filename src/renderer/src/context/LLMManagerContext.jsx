import { createContext, useContext, useState, useEffect } from 'react'
import ollama from 'ollama'

// Cr√©ez le contexte
const LLMManagerContext = createContext()

// Cr√©ez un hook personnalis√© pour utiliser le contexte
export const useLLMManager = () => {
  return useContext(LLMManagerContext)
}

const language = {
  en_US: { name: 'English (US)', flag: 'üá∫üá∏' },
  en_UK: { name: 'English (UK)', flag: 'üá¨üáß' },
  fr: { name: 'Fran√ßais', flag: 'üá´üá∑' },
  es: { name: 'Espa√±ol', flag: 'üá™üá∏' },
  de: { name: 'Deutsch', flag: 'üá©üá™' },
  it: { name: 'Italiano', flag: 'üáÆüáπ' },
  pt: { name: 'Portugu√™s', flag: 'üáßüá∑' },
  zh: { name: '‰∏≠Êñá', flag: 'üá®üá≥' },
  ja: { name: 'Êó•Êú¨Ë™û', flag: 'üáØüáµ' },
  ru: { name: '–†—É—Å—Å–∫–∏–π', flag: 'üá∑üá∫' },
  ar: { name: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©', flag: 'üá∏üá¶' },
  ko: { name: 'ÌïúÍµ≠Ïñ¥', flag: 'üá∞üá∑' },
  hi: { name: '‡§π‡§ø‡§Ç‡§¶‡•Ä', flag: 'üáÆüá≥' }
}

// Cr√©ez le Provider
export const LLMManagerProvider = ({ children }) => {
  const [models, setModels] = useState([])
  const [selectedModel, setSelectedModel] = useState('') // D√©faut : mod√®le valide
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)
  const [conversations, setConversations] = useState([]) // Stocke toutes les conversations
  const [currentConversationId, setCurrentConversationId] = useState(null) // ID de la conversation active

  const [currentLanguage, setCurrentLanguage] = useState('fr')

  const fetchModels = async () => {
    setLoading(true)
    setError(null)
    try {
      const modelsList = await ollama.list() // Utilisation directe de ollama.list()
      setModels(modelsList)
    } catch (err) {
      setError('Failed to fetch models')
      console.error(err)
    } finally {
      setLoading(false)
    }
  }


  const resetConversation = () => {
    const newConversation = {
      id: Date.now(), // Utilise un timestamp comme ID unique
      date: new Date(),
      messages: []
    }

    setConversations((prev) => [...prev, newConversation])
    setCurrentConversationId(newConversation.id)
  }

  const switchConversation = (conversationId = null) => {
    if (conversationId) {
      setCurrentConversationId(conversationId)
    } else {
      // Si aucun ID n'est fourni, retourne la derni√®re conversation
      const lastConversation = conversations[conversations.length - 1]
      if (lastConversation) {
        setCurrentConversationId(lastConversation.id)
      }
    }
  }

  const addContextToModel = (context) => {
    if (currentConversationId) {
      setConversations((prev) =>
        prev.map((conv) =>
          conv.id === currentConversationId
            ? {
                ...conv,
                messages: [...conv.messages, { sender: 'context', text: context }]
              }
            : conv
        )
      )
    } else {
      throw new Error('No active conversation to add context to.')
    }
  }

  const changeLanguage = (langCode) => {
    if (!language[langCode]) {
      throw new Error(`Language code ${langCode} is not supported.`)
    }

    setCurrentLanguage(langCode)

    // Ajouter un message contextuel au d√©but de la conversation
    const contextMessage = {
      sender: 'context',
      text: `It is imperative that you respond in ${language[currentLanguage].name}, It's imperative that you answer in Markdown format, with a compulsory main title and a hierarchy of subtitles if necessary. Don't hesitate to use all the MarkDown methods for formatting text and computer code.  .`
    }

    if (currentConversationId) {
      setConversations((prev) =>
        prev.map((conv) =>
          conv.id === currentConversationId
            ? {
                ...conv,
                messages: [contextMessage, ...conv.messages]
              }
            : conv
        )
      )
    } else {
      // Si aucune conversation active, cr√©er une nouvelle conversation avec le message contextuel
      const newConversation = {
        id: Date.now(),
        date: new Date(),
        messages: [contextMessage]
      }
      setConversations((prev) => [...prev, newConversation])
      setCurrentConversationId(newConversation.id)
    }

    console.log(conversations)
  }

  // Ajouter la fonction addMessageToConversation dans le LLMManagerProvider
  const addMessageToConversation = (message, sender = 'user') => {
    if (!currentConversationId) {
      // Si aucune conversation active, en cr√©er une nouvelle
      resetConversation();
    }

    setConversations((prev) =>
      prev.map((conv) =>
        conv.id === currentConversationId
          ? {
            ...conv,
            messages: [...conv.messages, { sender, text: message }]
          }
          : conv
      )
    );

    return currentConversationId;
  };


  useEffect(() => {
    fetchModels()
    resetConversation() // Initialise une premi√®re conversation par d√©faut
  }, [])

  const value = {
    models,
    selectedModel,
    setSelectedModel, // Expose la m√©thode pour changer le mod√®le s√©lectionn√©
    loading,
    error,
    refreshModels: fetchModels,
    resetConversation, // Expose la m√©thode pour r√©initialiser la conversation
    switchConversation, // Expose la m√©thode pour changer de conversation
    addContextToModel, // Expose la m√©thode pour ajouter un contexte
    changeLanguage, // Expose la m√©thode pour changer de langue
    conversations, // Expose toutes les conversations
    currentConversationId, // Expose l'ID de la conversation active
    currentLanguage,
    addMessageToConversation, // Expose la m√©thode pour ajouter un message √† la conversation

  }

  return <LLMManagerContext.Provider value={value}>{children}</LLMManagerContext.Provider>
}
